1. Что такое рекурсия и какие два обязательных компонента должна содержать рекурсивная функция?

Рекурсия - это процесс, при котором функция вызывает саму себя непосредственно или косвенно для решения задачи.

Два обязательных компонента:

· Базовый случай (Base case) - условие выхода из рекурсии, предотвращающее бесконечную рекурсию
· Рекурсивный шаг (Recursive step) - вызов функции самой себя с измененными параметрами, приближающими к базовому случаю

2. В чем разница между прямой и косвенной рекурсией?

· Прямая рекурсия: функция вызывает саму себя непосредственно
· Косвенная рекурсия: функция A вызывает функцию B, которая в свою очередь вызывает функцию A

3. Почему наивная рекурсивная реализация чисел Фибоначчи неэффективна?

Наивная рекурсия имеет экспоненциальную сложность O(2ⁿ) из-за многократного вычисления одних и тех же значений. Например, fib(5) вычисляет fib(3) два раза, fib(2) три раза и т.д.

4. Что такое мемоизация и как она помогает оптимизировать рекурсивные алгоритмы?

Мемоизация - техника кэширования результатов выполнения функций для последующего использования. Она преобразует экспоненциальную сложность в полиномиальную (O(n) для Фибоначчи).

5. Опишите стратегию «разделяй и властвуй» на примере алгоритма сортировки слиянием

Разделяй и властвуй состоит из трех шагов:

1. Разделить - разбить задачу на подзадачи
2. Властвовать - рекурсивно решить подзадачи
3. Объединить - объединить решения подзадач

Сортировка слиянием:

· Разделить массив пополам
· Рекурсивно отсортировать каждую половину
· Объединить отсортированные половины

6. В чем суть алгоритма backtracking?

Backtracking - метод поиска решений путем последовательного выбора вариантов и отката при обнаружении тупика. Он систематически перебирает все возможные варианты, отбрасывая заведомо неверные.

7. Какова временная сложность задачи о N ферзях?

Временная сложность - O(N!), так как для каждого ферзя количество возможных позиций уменьшается.

8. Сколько существует перестановок множества из n элементов?

Количество перестановок: n! = n × (n-1) × ... × 2 × 1

9. Чем отличаются перестановки от сочетаний?

· Перестановки: порядок элементов ВАЖЕН (ABC ≠ BAC)
· Сочетания: порядок элементов НЕ ВАЖЕН (ABC = BAC)

10. Какая разница между обходом дерева в глубину (DFS) и в ширину (BFS)?

· DFS (Depth-First Search): идет вглубь до конца перед возвратом, использует стек
· BFS (Breadth-First Search): идет по уровням, использует очередь

---

Анализ Реализации Судоку

Как работает backtracking в нашем решении?

1. Находим первую пустую клетку
2. Пробуем числа от 1 до 9
3. Если число допустимо - помещаем его и рекурсивно решаем остальную часть
4. Если рекурсия возвращает false - откатываемся (backtrack)
5. Если все числа проверены и не подходят - возвращаем false

Временная сложность:

В худшем случае O(9ⁿ), где n - количество пустых клеток, но на практике значительно лучше из-за проверок валидности.

Особенности реализации:

· Все три версии используют одинаковую логику
· Рекурсивный подход естественно подходит для backtracking
· Проверка валидности оптимизирует поиск

Этот код успешно решает стандартные судоку и демонстрирует принцип backtracking в действии на трех разных языках программирования.
